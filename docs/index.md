# Des classes traditionnelles à Pydantic en passant par DataClasses

**I. [Introduction](01-intro.md)**

- Définition d'une classe simple en Python
- Besoin de validation de données dans les applications
- Limitations en termes de conversion validation de données

**II. [Classes traditionnelles](02-traditional-classes.md)**

- Définition d'une classe simple en Python
- Création d'instances, attributs, et méthodes
- Limitations en termes de validation de données

**III. [DataClasses](03-dataclasses.md)**

- Présentation des DataClasses comme alternative
- Utilisation de l'annotation de type
- Implémentation d'une validation simple

**IV. [Classes Pydantic](04-pydantic-classes.md)**

- Présentation de Pydantic comme outil de validation avancée
- Installation et configuration de Pydantic
- Premier exemple avec Pydantic

**V. [Comparaison entre Classes traditionnelles, DataClasses et Pydantic](05-comparison.md)**

- Syntaxe et simplicité d'utilisation
- Capacités de validation de données

**VI. [Validation Cross-Field avec Pydantic](06-cross-field-validation.md)**

- Définition de dépendances entre champs
- Utilisation des méthodes de validation personnalisées
- Exemples pratiques de validation cross-field

**VII. [Lecture de fichiers JSON avec Pydantic](07-json-reading.md)**

- Chargement d'un fichier JSON
- Validation des données en entrée
- Manipulation des données validées

**VIII. [Cas d’utilisation](08-use-cases.md)**

- Lire ou écrire des fichiers de configuration (JSON, INI, YAML)
- Développer un site Web et/ou une API REST avec FastAPI
- S'interfacer avec les bases de données (SQL, NoSQL)

**IX. [Conclusion](09-conclusion.md)**

- Recapitulation des avantages de chaque approche
- Recommandations pour l'utilisation en fonction des besoins

**X. [Ressources supplémentaires](10-more-resources.md)**

- Documentation officielle de Python pour les DataClasses et Pydantic
- Liens vers des exemples pratiques et projets utilisant ces approches.

